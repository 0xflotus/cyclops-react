{"name":"simple-react","tagline":"Advanced asynchronous Streams & Data Structures for Java 8","body":"#SimpleReact : Powerful Future Streams & Async Data Structures for Java 8\r\n\r\nSimpleReact is a Java 8 concurrent Streaming library. We provide three Stream types, and three asynchronous data structures.\r\n\r\n## Build Status \r\n\r\n![Build health](https://travis-ci.org/aol/simple-react.svg)\r\n \r\n[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.aol.simplereact/simple-react/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.aol.simplereact/simple-react)\r\n\r\n\r\n##Stream Types\r\n\r\n* SimpleReactStream : this provides [a simple, focused API for Streaming Futures](https://github.com/aol/simple-react#simplereactstream--a-simple-fluent-api-for-functional-reactive-programming-with-java-8) based on the Promises / A++ spec.\r\n\r\n* [EagerFutureStream](https://github.com/aol/simple-react/wiki/EagerFutureStream) : An easy to use JDK 8 Stream of CompletableFutures, with all of the SimpleReact API methods, and scala-like [jOOλ Seq](http://www.jooq.org/products/jOO%CE%BB/javadoc/0.9.5/org/jooq/lambda/Seq.html) methods too. EagerFutureStream kicks of future tasks eagerly and can be run in either parallel or sequential (free-threaded) modes.\r\n\r\n* [LazyFutureStream](https://github.com/aol/simple-react/wiki/LazyFutureStream) : Provides a Lazy JDK 8 Stream of CompletableFutures (and Seq, and SimpleReact API methods). Can be used for constant proccessing (e.g. of data coming in off a SimpleReact asynchronous queue).\r\n \r\n ![simplereactstreaming types](https://cloud.githubusercontent.com/assets/9964792/6320732/f24f6458-badd-11e4-8e45-10373e3654f7.png)\r\n \r\n##Asynchronous datastructures\r\n\r\n* Queue : async queue that can be used to join producing and consuming streams. Multiple consuming streams (if connected) compete for messages on the queue.\r\n\r\n* Topic : async topic that can be used to join producing and consuming streams. Multiple consuming streams (if connected) recieve each message on the topic.\r\n\r\n* Signal : async signal that can stream changes, backed by either a Topic or a Queue.\r\n\r\n![simplereact datastructures](https://cloud.githubusercontent.com/assets/9964792/6320736/fb884daa-badd-11e4-801f-9a61a5213be2.png)\r\n \r\n\r\n\r\nSimpleReact is a parallel Stream library that implements java.util.stream.Stream. Under the hood, SimpleReact manages parallel streams as a stream of CompletableFutures. SimpleReact provides a simple core API based on the Promises / A++ spec, while also providing a full rich range of options by implementing both JDK 8 Stream, and the scala-like [jOOλ Seq](http://www.jooq.org/products/jOO%CE%BB/javadoc/0.9.5/org/jooq/lambda/Seq.html). SimpleReact goes beyond the traditional Java 8 Streaming interface by offering failure recovery, capture and retry functionality.\r\n\r\nIt is an easy to use, concurrent, reactive programming library for JDK 8.  It provides a focused, simple and limited core Reactive API aimed at solving the 90% use case - but without adding complexity. It is a core goal of SimpleReact to integrate with JDK 8 Stream libraries for maximum reuse and plugability.\r\n\r\nSee [A Simple Api, and a Rich Api](https://github.com/aol/simple-react/wiki/A-simple-API,-and-a-Rich-API) for details on SimpleReact core and the java Streaming interfaces.\r\n\r\n##Getting SimpleReact\r\n\r\n\r\n* [Adding SimpleReact as a dependency](https://github.com/aol/simple-react/wiki/Adding-SimpleReact-as-a-dependency)\r\n* [Search Maven](http://search.maven.org/#search%7Cga%7C1%7Ccom.aol.simplereact)\r\n\r\n\r\nFor Gradle : compile group: 'com.aol.simplereact', name:'simple-react', version:'0.84'\r\n\r\n##Documentation\r\n\r\n* [Reactive programming with Java 8 and simple-react: The Tutorial](https://medium.com/@johnmcclean/reactive-programming-with-java-8-and-simple-react-the-tutorial-3634f512eeb1)\r\n* [wiki](https://github.com/aol/simple-react/wiki)\r\n* [Javadoc](http://www.javadoc.io/doc/com.aol.simplereact/simple-react/0.84)\r\n* [Articles on medium](https://medium.com/search?q=simplereact)\r\n\r\n\r\n\r\n\r\n##Getting started\r\n\r\n* [See an illustrative getting started example](https://github.com/aol/simple-react/wiki/Getting-started-with-a-simple-example)\r\n\r\n* [What does Simple React do](https://github.com/aol/simple-react/wiki/What-does-SimpleReact-do%3F)\r\n\r\n* [Understanding simple-react pull/push model](https://medium.com/@johnmcclean/reactive-programming-with-java-8-and-simple-react-pull-push-model-70751d63628f)\r\n\r\n### Some less contrived / real world examples \r\n\r\n* [Example : Scaling microservices with NIO and SimpleReact](https://medium.com/@johnmcclean/scaling-up-microservices-with-nio-and-simplereact-b2e8f41fdd68)\r\n\r\n [Building a non blocking NIO rest client](https://github.com/aol/simple-react/wiki/Example-:-Building-a-non-blocking-NIO-rest-client)\r\n\r\n* [Example : Plumbing Java 8 Streams with Queues, Topics and Signals](https://medium.com/@johnmcclean/plumbing-java-8-streams-with-queues-topics-and-signals-d9a71eafbbcc)\r\n\r\n* [Example : Bulk loading files](https://github.com/aol/simple-react/wiki/Example-:-Bulk-loading-files)\r\n\r\n* [Example : Implementing a Quorum](https://github.com/aol/simple-react/wiki/Example-:-Implementing-a-Quorum)\r\n\r\n##Why SimpleReact\r\n\r\nWhy daisy-chain together CompletableFuture's by hand? SimpleReact allows you to put together sophisticated concurrent chains of CompletableFutures with a very easy to use API.\r\n\r\nSimpleReact is built on top of JDK standard libraries and unlike other Reactive implementations for Java, specifically targets JDK 8 and thus reuses rather than reinvents  Streams, Functional interfaces etc. SimpleReact augments the *parallel* Streams functionality in JDK by providing a facade over both the Streams and CompletableFuture apis. Under-the-hood, SimpleReact *is* a Stream of CompletableFutures, and presents that externally as an api somewhat inspired by the Javascript Promises / A+ Spec (https://promisesaplus.com/).\r\n\r\nEverything is concurrent in SimpleReact. While this does limit some of the syntax-sugar we can provide directly, the small & focused SimpleReact Api together with the Apis of the underlying JDK 8 primitives offer often surprising levels of power and flexibility.\r\n\r\n* [See an example of using CompletableFuture directly with SimpleReact](https://github.com/aol/simple-react/wiki/Example-:-Reacting-to-Asynchronous-Events-with-a-Stream-of-CompletableFutures)\r\n\r\n#SimpleReact Streams and commands\r\n\r\n* [List of operators] (https://github.com/aol/simple-react/wiki/A-simple-API,-and-a-Rich-API)\r\n* [Batching, control, sharding and zipping operators ](https://github.com/aol/simple-react/wiki/Batching,-Time-Control,-Sharding-and-Zipping-Operators)\r\n\r\n##limit\r\n\r\n###EagerFutureStream\r\n\r\nWhen a limit is applied in an EagerFutureStream, all future tasks for a stage are executed and the first n tasks (specified by the limit) are passed as input to the next stage. In a sequential stream, tasks will complete in the order they are specified. This results in more deterministic output, but may be less efficient / performant if extract data from external sources.\r\n\r\n![eagerfuturestream limit](https://cloud.githubusercontent.com/assets/9964792/6320759/570d6368-bade-11e4-8685-cf73af4d54f7.png)\r\n\r\n\r\n\r\n\r\n###LazyFutureStream\r\n\r\nWhen a limit is applied to  a LazyFutureStream it is applied to the tasks before they start. For versions before the planned SimpleReact v0.6, specifying a limit early in a LazyFutureStream that you don’t want to run constantly is recommended. v0.6 will include the ability for consuming threads to auto-close producing threads and reduce the need for programatic management of LazyFutureStreams by users.\r\n\r\n![lazyfuturestream limit](https://cloud.githubusercontent.com/assets/9964792/6320738/04cd3678-bade-11e4-9268-b224b6c2dd21.png)\r\n\r\n\r\n\r\n###SimpleReactStream\r\n\r\nThe SimpleReactStream API doesn’t provide an explicit limit mechanism. But does provide a Predicate (com.aol.simple.react.predicates.Predicates.limit) that when provided to the filter method behaves exactly as EagerFutureStream limit.\r\n\r\n\r\n##skip\r\n\r\nSkip will perform as in the same way as Limit for all three Stream types but skips the first X data points instead.\r\n\r\n###EagerFutureStream\r\nFor EagerFutureStream specifying a skip will skip the first X results returned from the previous stage.\r\n\r\n![eagerfuturestream skip](https://cloud.githubusercontent.com/assets/9964792/6329112/70f48c02-bb65-11e4-908b-bab3003c6dfe.png)\r\n\r\n###LazyFutureStream\r\nFor LazyFutureStream specifying a skip will skip the first X tasks specified in the previous stage.\r\n\r\n![lazyfuturestream - skip](https://cloud.githubusercontent.com/assets/9964792/6329113/7291ff54-bb65-11e4-8d40-024e731a588e.png)\r\n\r\n###SimpleReactStream\r\nFor SimpleReactStream using com.aol.simple.react.predicates.Predicates.skip with filter, will skip the first X results returned.\r\n\r\n##map / then\r\n\r\n###EagerFutureStream, LazyFutureStream, SimpleReactStream\r\n\r\nFor all three Streams map or then converts input data in one format to output data in another.\r\n\r\n![stream map/then](https://cloud.githubusercontent.com/assets/9964792/6320750/3e6ccaa6-bade-11e4-9ebf-ad63996c489f.png)\r\n\r\n##retry\r\n\r\n###EagerFutureStream, LazyFutureStream, SimpleReactStream\r\n\r\nRetry allows a task in a stage to be retried if it fails\r\n\r\n![stream retry](https://cloud.githubusercontent.com/assets/9964792/6320754/4ea4061e-bade-11e4-8692-481e0dc0e3f9.png)\r\n\r\n##onFail\r\n\r\n###EagerFutureStream, LazyFutureStream, SimpleReactStream\r\nFor all three Streams onFail allows recovery from a Streaming stage that fails.\r\n\r\n![stream onFail](https://cloud.githubusercontent.com/assets/9964792/6320747/34c8d666-bade-11e4-817d-2d4c5c3fa6e7.png)\r\n\r\n##capture\r\n\r\n###EagerFutureStream, LazyFutureStream, SimpleReactStream\r\n\r\nCapture allows error handling for unrecoverable errors.\r\n\r\n![eagerfuturestream capture](https://cloud.githubusercontent.com/assets/9964792/6329474/8ee5cdea-bb68-11e4-96c3-d8335879408e.png)\r\n\r\n##flatMap\r\n\r\n###EagerFutureStream, LazyFutureStream, SimpleReactStream\r\n\r\nFor all three Streams specifying a flatMap splits a single result into multiple tasks by returning a Stream from the flatMap method.\r\n\r\n![stream flatMap](https://cloud.githubusercontent.com/assets/9964792/6320742/18ce599a-bade-11e4-8bdb-8909c71da06c.png)\r\n\r\n##allOf (async collect)\r\n###EagerFutureStream, LazyFutureStream, SimpleReactStream\r\n\r\nallOf is the inverse of flatMap. It rolls up a Stream from a previous stage, asynchronously into a single collection for further processing as a group.\r\n\r\n![stream allOf](https://cloud.githubusercontent.com/assets/9964792/6320739/0a98c8ba-bade-11e4-9097-0b3209a5aba1.png)\r\n\r\n##anyOf\r\n###EagerFutureStream, LazyFutureStream, SimpleReactStream\r\n\r\nanyOf progresses the flow with the first result received.\r\n\r\n![eagerfuturestream anyof](https://cloud.githubusercontent.com/assets/9964792/6586388/01c07982-c771-11e4-90fc-9fae9ec17aba.png)\r\n\r\n\r\n##block / collect\r\n###EagerFutureStream, LazyFutureStream, SimpleReactStream\r\n\r\nBlock behaves like allOf except that it blocks the calling thread until the Stream has been processed.\r\n\r\n![eagerfuturestream block](https://cloud.githubusercontent.com/assets/9964792/6329382/9d475a76-bb67-11e4-9fe9-b081046a659b.png)\r\n\r\n##zip\r\n###EagerFutureStream, LazyFutureStream, SimpleReactStream\r\n\r\nZip merges two streams by taking the next available result from each stream. For sequential streams, this will be determined by start order - for parallel streams, order is non-deterministic\r\n\r\n![stream zip](https://cloud.githubusercontent.com/assets/9964792/6320745/2a52717e-bade-11e4-93c7-8965a2d6f3ab.png)\r\n\r\n\r\n##toQueue\r\n###EagerFutureStream, LazyFutureStream, SimpleReactStream\r\n\r\ntoQueue creates a new simplereact.aysnc.Queue that is populated asynchronously by the current Stream. Another Stream (Consumer) can be created from the Queue by calling queue.toStream()\r\n![eagerfuturestream toqueue](https://cloud.githubusercontent.com/assets/9964792/6329104/5eb15034-bb65-11e4-9f18-82c34065465f.png)\r\n\r\n#Choosing A Stream Type\r\n\r\nThe key components in choosing what type of Stream to create are :\r\n\r\n1. Eager or Lazy\r\n2. Sequential or Parallel\r\n4. What data stream should be provided with\r\n5. Optimising Stream performance\r\n\r\n##Eager Streams and Lazy Streams\r\n\r\nSimpleReactStreams can be either Eager or Lazy, by default they are Eager.\r\n\r\nEager Streams start processing immediately, while Lazy Streams start processing when a terminal operation is invoked.\r\n\r\nSimpleReact provides builder classes, and JDK 8 Stream style factory methods on the Stream itself that can be used to create appropriate Streams.\r\n\r\n*SimpleReact - builder class for SimpleReact\r\n\r\n*EagerReact - builder class for EagerFutureStreams\r\n\r\n*LazyReact - builder class for LazyFutureStreams\r\n\r\n\r\nLazy Streams can be effectively infinite. \r\n\r\n###Why would you want an infinite Stream? \r\n\r\nIn the real world this could be a Stream that receives and reacts to events for as long as an application runs.\r\n\r\nEager Streams are eagerly materialised into CompletableFuture objects, so can’t be infinite or your application will run out of Memory.\r\n\r\n###Why would you want an eager stream?\r\n\r\nEager streams are useful for processing parallel tasks starting immediately. Such as bulk loading files from disk, data to remote store, or reading from a remote server.\r\n\r\n##Sequential or Parallel\r\n\r\nSimpleReact streams can either be parallel or sequential. For either type, the underlying model is identical. CompletableFuture tasks are sent to a task executor for execution. In a Sequential Stream a task executor with a single thread is used (free thread model). In a parallel Stream a task executor with many threads can be used instead.\r\n\r\n    LazyFutureStream.sequentialBuilder().of(1,2,3)\r\n    EagerFutureStream.sequentialBuilder().of(1,2,3)\r\n\r\n    LazyFutureStream.parallelBuilder().of(1,2,3)\r\n    EagerFutureStream.parallelBuilder().of(1,2,3)\r\n\r\n###Why would you want a sequential stream?\r\n\r\nSimpleReact sequential streams don’t block the current thread, unless block or a terminal operation is called. So if you want to offload some sequential processing to a separate thread, sequential streams are a good choice.\r\n\r\n###Why would you want a parallel stream?\r\n\r\nParallel streams are useful for taking advantage of multi-core processors. For CPU bound heavy processing tasks, spreading the load across multiple cores can make processing faster. For I/O bound tasks taking advantage of threads to unblock the current thread of execution can also be advantageous (also see NIO examples later). SimpleReact parallel streams are easy to create and offer much wider options for control than standard JDK parallel Streams (such as retry, failure handling, targeting any task executor and much more!).\r\nProviding Data to a Stream\r\n\r\nThe SimpleReact class provides a number of methods, mostly starting with the word ‘react’ that can be used to provide data to your reactive Stream.\r\n\r\ne.g. \r\n\r\n\tEagerFutureStream.parallel(5).reactToCollection(list);\r\n\tLazyFutureStream.sequentialBuilder().react( ()->1, ()->”hello world”);\r\n\tLazyFutureStream.parallel(10).reactInfinitely( ()-> count.incrementAndGet())\r\n\r\nOr you can generate a Stream from a SimpleReact datastructure\r\n\r\n\tQueue queue = new Queue();\r\n\tFutureStream stream = queue.stream(); //creates a lazy, infinite, parallel stream\r\n\r\nOr from any Java datastructure\r\n\r\n\tList<Integer> list = new ArrayList<>();\r\n\tEagerStream.of(list);\r\n\r\nOr Array\r\n\r\n\tLazyStream.of(1,2,3,4)\r\n\r\n###Configuring concurrency\r\n\r\nTaskExecutor and RetryExecutor configuration can be changed on per stage basis of in any of the SimpleReact streams\r\n\r\n##Data flow of the SimpleReactStream API\r\n\r\n\r\n### SimpleReactStream : A Simple Fluent Api for Functional Reactive Programming with Java 8\r\n\r\n\r\n*EagerFutureStream and LazyFutureStream* have this functionality in addition to JDK 8 Stream functionality and [jOOλ Seq](http://www.jooq.org/products/jOO%CE%BB/javadoc/0.9.5/org/jooq/lambda/Seq.html) methods, applied to a Stream of JDK 8 CompletableFutures.\r\n\r\nSimpleReact starts with an array of Suppliers which generate data other functions will react to. Each supplier will be passed to an Executor to be executed, potentially on a separate thread. Each additional step defined when calling Simple React will also be added as a linked task, also to be executed, potentially on a separate thread.\r\n\r\n##Example 1 : reacting with completablefutures\r\n\r\nReact **with**\r\n\r\n\t\t\tList<CompletableFuture<Integer>> futures = new SimpleReact()\r\n\t\t\t\t.<Integer> react(() -> 1, () -> 2, () -> 3)\r\n\t\t\t\t.with(it -> it * 100);\r\n\r\nIn this instance, 3 suppliers generate 3 numbers. These may be executed in parallel, when they complete each number will be multiplied by 100 - as a separate parrellel task (handled by a ForkJoinPool or configurable task executor). A List of Future objects will be returned immediately from Simple React and the tasks will be executed asynchronously.\r\nReact with does not block.\r\n##Example 2 : chaining\r\n\r\nReact **then** / **map**\r\n\r\n\t \tnew SimpleReact()\r\n\t \t\t\t.<Integer> react(() -> 1, () -> 2, () -> 3)\r\n\t\t\t\t.then(it -> it * 100)\r\n\t\t\t\t.then(it -> \"*\" + it)\r\n\r\n\r\nReact then allows event reactors to be chained. Unlike React with, which returns a collection of Future references, React then is a fluent interface that returns the React builder - allowing further reactors to be added to the chain.\r\nReact then does not block.\r\nReact with can be called after React then which gives access to the full CompleteableFuture api. CompleteableFutures can be passed back into SimpleReact via SimpleReact.react(streamOfCompleteableFutures);\r\nSee this blog post for examples of what can be achieved via CompleteableFuture :- http://www.nurkiewicz.com/2013/12/promises-and-completablefuture.html\r\n\r\nReact **retry**\r\n\r\n\t \tnew SimpleReact()\r\n\t \t\t\t.<Integer> react(() -> url1, () -> url2, () -> url3)\r\n\t\t\t\t.retry(it -> readRemoteService(it))\r\n\t\t\t\t.then(it ->  extractData(it))\r\n\t\t\t\t.then(it -> writeToQueue(it))\r\n\r\n\r\nRetry allows a stage to be retried a configurable number of times. Retry functionlity is provided by async-retry (https://github.com/nurkiewicz/async-retry), that provides a very configurable mechanism for asynchronous retrying based on CompletableFutures.\r\nIn SimpleReact a RetryExecutors can be plugged in at any stage. Once plugged in it will be used for the current and subsequent stages of the Stream (until replaced).\r\n\r\ne.g.  \r\n\r\n\tnew SimpleReact()\r\n\t\t.<Integer> react(() -> url1, () -> url2, () -> url3)\r\n\t\t.withRetrier(retryExecutor)\r\n\t\t.retry(it -> readRemoteService(it))\r\n\r\nTo configure a retry executor follow the instructions on https://github.com/nurkiewicz/async-retry. E.g :-\r\n\r\n\t\t\r\n    ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();\r\n    RetryExecutor executor = new AsyncRetryExecutor(scheduler).\r\n       retryOn(SocketException.class).\r\n       withExponentialBackoff(500, 2).     //500ms times 2 after each retry\r\n       withMaxDelay(10_000).               //10 seconds\r\n       withUniformJitter().                //add between +/- 100 ms randomly\r\n       withMaxRetries(20);\r\n       \r\nReact and **flatMap**       \r\n       \r\n##Example 3: blocking\r\n\r\nReact and **block**\r\n\r\n\t\t\tList<String> strings = new SimpleReact()\r\n\t\t\t\t.<Integer> react(() -> 1, () -> 2, () -> 3)\r\n\t\t\t\t.then(it -> it * 100)\r\n\t\t\t\t.then(it -> \"*\" + it)\r\n\t\t\t\t.block();\r\n\t\t\t\t\t\t\r\nIn this example, once the current thread of execution meets the React block method, it will block until all tasks have been completed. The result will be returned as a List. The Reactive tasks triggered by the Suppliers are non-blocking, and are not impacted by the block method until they are complete. Block, only blocks the current thread.\r\n\r\n##Example 4: breakout\r\n\r\nSometimes you may not need to block until all the work is complete, one result or a subset may be enough. To faciliate this, block can accept a Predicate functional interface that will allow SimpleReact to stop blocking the current thread when the Predicate has been fulfilled. E.g.\r\n\r\n\t\t\tList<String> strings = new SimpleReact()\r\n\t\t\t\t.<Integer> react(() -> 1, () -> 2, () -> 3)\r\n\t\t\t\t.then(it -> it * 100)\r\n\t\t\t\t.then(it -> \"*\" + it)\r\n\t\t\t\t.block(status -> status.getCompleted()>1);\r\n\r\nIn this example the current thread will unblock once more than one result has been returned. The available fields on the status object are :-\r\ncompleted\r\nerrors\r\ntotal\r\nelapsedMillis\r\n\r\n##Example 5 : onFail\r\n\r\nReact **onFail**\r\nonFail allows disaster recovery for each task (a separate onFail should be configured for each react phase that can fail). E.g. if reading data from an external service fails, but default value is acceptable - onFail is a suitable mechanism to set the default value.\r\n\r\n\t\t\tList<String> strings = new SimpleReact()\r\n\t\t\t\t.<Integer> react(() -> 100, () -> 2, () -> 3)\r\n\t\t\t\t.then(it -> {\r\n\t\t\t\t\tif (it == 100)\r\n\t\t\t\t\t\tthrow new RuntimeException(\"boo!\");\r\n\t\t\r\n\t\t\t\t\treturn it;\r\n\t\t\t\t})\r\n\t\t\t\t.onFail(e -> 1)\r\n\t\t\t\t.then(it -> \"*\" + it)\r\n\t\t\t\t.block();\r\n\r\nIn this example, should the first \"then\" phase fail, the default value of 1 will be used instead.\r\n\r\n##Example 6: non-blocking\r\n\r\nReact and **allOf**\r\n\r\nallOf is a non-blocking equivalent of block. The current thread is not impacted by the calculations, but the reactive chain does not continue until all currently alloted tasks complete. The allOf task is then provided with a list of the results from the previous tasks in the chain. Any parallelStreams used inside allOf will reuse the SimpleReact ExecutorService - if it is a ForkJoinPool (which it is by default), rather than the Common ForkJoinPool parallelStreams use by default. \r\n\r\n        \tboolean blocked[] = {false};\r\n\t\t\tnew SimpleReact()\r\n\t\t\t\t.<Integer> react(() -> 1, () -> 2, () -> 3)\t\r\n\t\t\t\t.then(it -> {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tThread.sleep(50000);\r\n\t\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tblocked[0] =true;\r\n\t\t\t\t\treturn 10;\r\n\t\t\t\t})\r\n\t\t\t\t.allOf( it -> it.size());\r\n\r\n\t\t\r\n\t\t\tassertThat(blocked[0],is(false));\r\n\r\nIn this example, the current thread will continue and assert that it is not blocked, allOf could continue and be executed in a separate thread.\r\n\r\nfirst() is a useful method to extract a single value from a dataflow that ends in allOf. E.g. \r\n\r\n\r\n        \tboolean blocked[] = {false};\r\n\t\t\tint size = new SimpleReact()\r\n\t\t\t\t.<Integer> react(() -> 1, () -> 2, () -> 3)\t\r\n\t\t\t\t.then(it -> {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tThread.sleep(50000);\r\n\t\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tblocked[0] =true;\r\n\t\t\t\t\treturn 10;\r\n\t\t\t\t})\r\n\t\t\t\t.allOf( it -> it.size()).first();\r\n\r\n\t\t\r\n\t\t\tassertThat(blocked[0],is(false));\r\n\r\n##Example 7: non-blocking with the Stream api\r\n\r\n             List<Integer> result =new SimpleReact()\r\n             \t.<Integer> react(() -> 1, () -> 2, () -> 3)\r\n\t\t\t\t.then(it -> {\r\n\t\t\t\t\treturn it*200;\r\n\t\t\t\t})\r\n\t\t\t\t.<Integer,Integer>allOf( (it )->{\r\n\t\t\t\t\treturn it.parallelStream()\r\n\t\t\t\t\t.filter( f -> f>300)\r\n\t\t\t\t\t.map(m -> m-5)\r\n\t\t\t\t\t.reduce(0, (acc,next) -> acc+next); \r\n\t\t\t\t}).block();\r\n\r\n\t\t\r\n\t\t\tassertThat(result.size(),is(1));\r\n\t\t\tassertThat(result.get(0),is(990));\r\n\r\n\r\nIn this example we block the current thread to get the final result, the allOf task uses the Streams api to setup another FRP chain that takes the inputs from our initial parellel jobs ([1,2,3] -> [200,400,600]), and does a filter / map/ reduce on them in parallel.\r\n\r\n##Example 6 : capturing exceptions\r\n\r\nReact *capture*\r\n\r\nonFail is used for disaster recovery (when it is possible to recover) - capture is used to capture those occasions where the full pipeline has failed and is unrecoverable.\r\n\r\n\t\t\tList<String> strings = new SimpleReact()\r\n\t\t\t\t.<Integer> react(() -> 1, () -> 2, () -> 3)\r\n\t\t\t\t.then(it -> it * 100)\r\n\t\t\t\t.then(it -> {\r\n\t\t\t\t\tif (it == 100)\r\n\t\t\t\t\t\tthrow new RuntimeException(\"boo!\");\r\n\t\t\r\n\t\t\t\t\treturn it;\r\n\t\t\t\t})\r\n\t\t\t\t.onFail(e -> 1)\r\n\t\t\t\t.then(it -> \"*\" + it)\r\n\t\t\t\t.then(it -> {\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (\"*200\".equals(it))\r\n\t\t\t\t\t\tthrow new RuntimeException(\"boo!\");\r\n\t\t\r\n\t\t\t\t\treturn it;\r\n\t\t\t\t})\r\n\t\t\t\t.capture(e -> logger.error(e.getMessage(),e))\r\n\t\t\t\t.block();\r\n\r\n\r\nIn this case, strings will only contain the two successful results (for ()->1 and ()->3), an exception for the chain starting from Supplier ()->2 will be logged by capture. Capture will not capture the exception thrown when an Integer value of 100 is found, but will catch the exception when the String value \"*200\" is passed along the chain.\r\n\r\n##Example 7 : using the Streams Api\r\n\r\nReact and the *Streams Api*\r\n\r\nA SimpleReact Stage implements both [java.util.stream.Stream](http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html) and [org.jooq.lambda](http://www.jooq.org/products/jOO%CE%BB/javadoc/0.9.5/org/jooq/lambda/Seq.html) Streaming interfaces. This section describes how to interact with the JDK implementation of java.util.stream.Stream. \r\n\r\nIt is possible to reuse the internal SimpleReact ExecutorService for JDK 8 parallelStreams. SimpleReact uses a ForkJoinPool as the ExecutorService by default, and to reuse the ExecutorService with parallelStreams it must be a ForkJoinPool - so if you want to supply your own make sure it is also a ForkJoinPool. The easiest way to do this is via the submitAndBlock method.\r\n\r\n*Detailed Explanation* A mechanism to share the SimpleReact ExecutorService with JDK Parallel Streams is provided via the *collectResults* method. NB This will only actually share the ExecutorService if it is an instance of ForkJoinPool (limitation imposed on JDK side). This method collects the results from the current active tasks, and clients are given the full range of SimpleReact blocking options.  The results will then be made available to a user provided function when the *submit* method is called. The submit method will ensure that the user function is executed in such a way that the SimpleReact ExecutorService will also be used by ParallelStreams. It does this by submiting the user function & results to the ForkJoinPool and ParallelStreams has been written in such away to resuse any ForkJoinPool it is executed inside.\r\n \r\nA way to merge all these steps into a single method is also provided (submitAndBlock). \r\n\r\nExample :\r\n\r\n\t\t Integer result = new SimpleReact()\r\n\t\t\t\t.<Integer> react(() -> 1, () -> 2, () -> 3)\r\n\t\t\t\t.then(it -> it * 200)\r\n\t\t\t\t.<List<Integer>,Integer>submitAndblock(\r\n\t\t\t\t\t\tit -> it.parallelStream()\r\n\t\t\t\t\t\t\t\t.filter(f -> f > 300)\r\n\t\t\t\t\t\t\t\t.map(m -> m - 5)\r\n\t\t\t\t\t\t\t\t.reduce(0, (acc, next) -> acc + next));\r\n\t\t\t\t\t\t\t\t\r\nTo use a different ExecutorService than SimpleReact's internal ExecutorService leverae parallelStream directly from block() \r\n\r\n\t\t\tImmutableMap<String,Integer> dataSizes = new SimpleReact()\r\n\t\t\t\t.<Integer> react(() -> 1, () -> 2, () -> 30,()->400)\r\n\t\t\t\t.then(it -> it * 100)\r\n\t\t\t\t.then(it -> \"*\" + it)\r\n\t\t\t\t.<String>block()\r\n\t\t\t\t.parallelStream()\r\n\t\t\t\t.filter( it -> it.length()>3)\r\n\t\t\t\t.map(it -> ImmutableMap.of(it,it.length()))\r\n\t\t\t\t.reduce(ImmutableMap.of(),  (acc, next) -> ImmutableMap.<String, Integer>builder()\r\n\t\t\t\t\t      .putAll(acc)\r\n\t\t\t\t\t      .putAll(next)\r\n\t\t\t\t\t      .build());\r\n\r\nIn this example the converted Strings are filtered by length and an ImmutableMap created using the Java 8 Streams Api.\r\n\r\n\r\n##Example 8 : peeking at the current stage\r\n\r\nParticularly during debugging and troubleshooting it can be very useful to check the results at a given stage in the dataflow. Just like within the Streams Api, the peek method can allow you to do this.\r\n\r\nExample :\r\n\r\n\tList<String> strings = new SimpleReact()\r\n\t\t\t\t.<Integer> react(() -> 1, () -> 2, () -> 3)\r\n\t\t\t\t.then(it -> it * 100)\r\n\t\t\t\t.<String>then(it -> \"*\" + it)\r\n\t\t\t\t.peek((String it) -> logger.info(\"Value is {}\",it))\r\n\t\t\t\t.block();\r\n\t\t\t\t\r\n##Example 9 : filtering results\r\n\r\nThe filter method allows users to filter out results they are not interested in.\r\n\r\nExample :\r\n\r\n\tList<String> result = new SimpleReact()\r\n\t\t\t\t.<Integer> react(() -> 1, () -> 2, () -> 3)\r\n\t\t\t\t.then(it -> \"*\" + it)\r\n\t\t\t\t.filter(it -> it.startsWith(\"*1\"))\r\n\t\t\t\t.block();\r\n\r\n##Example 10 : Concurrent iteration\r\n\r\nSimpleReact provides a mechanism for starting a dataflow an iterator.\r\n\r\n\tList<Integer> list = Arrays.asList(1,2,3,4);\r\n\tList<String> strings = new SimpleReact()\r\n\t\t\t\t.<Integer> react(list.iterator() ,list.size())\r\n\t\t\t\t.then(it -> it * 100)\r\n\t\t\t\t.then(it -> \"*\" + it)\r\n\t\t\t\t.block(); \r\n\t\t\t\t\r\n##Example 11 : Infinite generators & iterators\r\n\r\nSince v0.2 SimpleReact supports fully Infinite Streams, See :- \r\n\r\nhttps://github.com/aol/simple-react/wiki/Infinite-Streams-in-SimpleReact\r\nhttps://medium.com/@johnmcclean/plumbing-java-8-streams-with-queues-topics-and-signals-d9a71eafbbcc\r\n\r\n\r\nSimpleReact provides a mechanism over JDK Stream iterate and generate which will create 'infinite' Streams of data to react to. Because SimpleReact eagerly collects these Streams (when converting to *active* CompletableFutures), the SimpleReact api always requires a maximum size parameter to be set.\r\n\r\n\tList<String> strings = new SimpleReact()\r\n\t\t\t\t.<Integer> react(() -> count++ ,SimpleReact.times(4))\r\n\t\t\t\t.then(it -> it * 100)\r\n\t\t\t\t.then(it -> \"*\" + it)\r\n\t\t\t\t.capture(e -> capture++)\r\n\t\t\t\t.block();\r\n\r\n##Example 12 : Splitting and merging SimpleReact dataflows\r\n\r\nA simple example below where a dataflow is split into 3, processed separately then merged back into a single flow.\r\n\r\n\tStage<String> stage = new SimpleReact()\r\n\t\t\t\t.<Integer> react(() -> 1, () -> 2, () -> 3)\r\n\t\t\t\t.then(it -> \"*\" + it);\r\n\t\tStage<String> stage1 = stage.filter(it -> it.startsWith(\"*1\"));\r\n\t\tStage<String> stage2 = stage.filter(it -> it.startsWith(\"*2\"));\r\n\t\tStage<String> stage3 = stage.filter(it -> it.startsWith(\"*3\"));\r\n\t\t\r\n\t\tstage1 = stage1.then(it -> it+\"!\");\r\n\t\tstage2 = stage2.then(it -> it+\"*\");\r\n\t\tstage3 = stage3.then(it -> it+\"%\");\r\n\t\t\r\n\t\tList<String> result = stage1.merge(stage2).merge(stage3).block();\r\n\r\n      #Feature matrix\r\n\r\n\r\n#Queues, Topics, Signals quick overview\r\n\r\nQueues can be populated asyncrhonously by a Stream and read at will be consumers. Each message added to a queue can only be read by a single consumer, once a consuming Stream has removed a message from the Queue it is gone.\r\n\r\n![Visualisation of a SimpleReact dataflow : Queues](https://cloud.githubusercontent.com/assets/9964792/6219467/c48aed46-b621-11e4-9aaa-9dcea3019024.png)\r\n\r\nTopics can be populated asynchronously by a Stream and read at will by consumers. Each consumer is guaranteed to recieve every message sent to a topic once connected.\r\n\r\n![Visualisation of a SimpleReact dataflow : Topics](https://cloud.githubusercontent.com/assets/9964792/6219474/db8243aa-b621-11e4-89d3-b854aa00adce.png)\r\n\r\nSignals track changes, and can provide those changes as continuous or discrete Streams.\r\n\r\n![Visualisation of a SimpleReact dataflow : Signals](https://cloud.githubusercontent.com/assets/9964792/6219478/e18ca33a-b621-11e4-9a51-a07e7c5364d7.png)\r\n\r\n\r\n\r\n| FEATURE                                          | SimpleReactStream   | EagerFutureStream   | LazyFutureStream    | JDK 8 Stream (sequential) | JDK 8 Stream (parallel) |\r\n|--------------------------------------------------|---------------------|---------------------|---------------------|---------------------------|-------------------------| \r\n| Focused Simple API                               | Yes                 | No                  | No                  | No                        | No                      | \r\n| Full JDK 8 Streams API                           | No                  | Yes                 | Yes                 | Yes                       | Yes                     | \r\n| Scala-like Seq (zip/ concate etc)                | No                  | Yes                 | Yes                 | No                        | No                      | \r\n| Multithreading                                   | Yes                 | Yes                 | Yes                 | No                        | Yes                     | \r\n| Free-threading (target single thread)            | Yes                 | Yes                 | Yes                 | No                        | No                      | \r\n| Sequential operation                             | Yes                 | Yes                 | Yes                 | Yes                       | No                      | \r\n| Target different executors per stage             | Yes                 | Yes                 | Yes                 | No                        | No                      | \r\n| Concurrency configurability                      | Highly configurable | Highly configurable | Highly configurable | No                        | Limited                 | \r\n| Failure recovery                                 | Yes                 | Yes                 | Yes                 | No                        | No                      | \r\n| Retry support                                    | Yes                 | Yes                 | Yes                 | No                        | No                      | \r\n| Time control                                     | No                  | Yes                 | Yes                 | No                        | No                      | \r\n| Batching                                     \t   | No                  | Yes                 | Yes                 | No                        | No                      |\r\n| Sharding                                     \t   | No                  | Yes                 | Yes                 | No                        | No                      | \r\n| Zipping                                     \t   | No                  | Yes                 | Yes                 | No                        | No                      |\r\n| Compatible with SimpleReact async datastructures | Yes                 | Yes                 | Yes                 | No                      \t | No                      | \r\n| Lazy (until terminal op)                         | Yes                 | No                  | Yes                 | Yes                       | Yes                     | \r\n| Eager                                            | Yes                 | Yes                 | No                  | No                        | No                      | \r\n| infinite streams                                 | Yes                 | No                  | Yes                 | Yes                       | Yes                     | \r\n| each task executed independently                 | Yes                 | Yes                 | Yes                 | No                        | No                      | \r\n| async results collection                         | Yes                 | Yes                 | Yes                 | No                        | No                      | \r\n      \r\n\t\t\r\n# License\r\n\r\nSimple React is licensed under the Apache 2.0 license.\t\t\r\n\r\nhttp://www.apache.org/licenses/LICENSE-2.0\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}