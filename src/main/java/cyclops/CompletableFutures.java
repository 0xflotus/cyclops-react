package cyclops;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Stream;

import com.aol.cyclops2.hkt.Higher;
import cyclops.async.Future;
import cyclops.function.Fn3;
import cyclops.function.Fn4;
import cyclops.function.Monoid;
import cyclops.function.Reducer;
import cyclops.higherkindedtypes.CompletableFutureKind;
import cyclops.typeclasses.Pure;
import cyclops.typeclasses.comonad.Comonad;
import cyclops.typeclasses.foldable.Foldable;
import cyclops.typeclasses.functor.Functor;
import cyclops.typeclasses.instances.General;
import cyclops.typeclasses.monad.*;
import org.reactivestreams.Publisher;

import cyclops.monads.AnyM;
import cyclops.stream.ReactiveSeq;
import com.aol.cyclops2.data.collections.extensions.CollectionX;
import cyclops.collections.ListX;
import com.aol.cyclops2.types.Value;
import cyclops.monads.Witness;

import lombok.experimental.UtilityClass;

/**
 * Utilty methods for working with JDK CompletableFutures
 * 
 * @author johnmcclean
 *
 */
@UtilityClass
public class CompletableFutures {


    /**
     * Perform a For Comprehension over a CompletableFuture, accepting 3 generating function.
     * This results in a four level nested internal iteration over the provided CompletableFutures.
     *
     *  <pre>
     * {@code
     *
     *   import static com.aol.cyclops2.reactor.CompletableFutures.forEach4;
     *
    forEach4(CompletableFuture.just(1),
    a-> CompletableFuture.just(a+1),
    (a,b) -> CompletableFuture.<Integer>just(a+b),
    a                  (a,b,c) -> CompletableFuture.<Integer>just(a+b+c),
    Tuple::tuple)
     *
     * }
     * </pre>
     *
     * @param value1 top level CompletableFuture
     * @param value2 Nested CompletableFuture
     * @param value3 Nested CompletableFuture
     * @param value4 Nested CompletableFuture
     * @param yieldingFunction Generates a result per combination
     * @return CompletableFuture with a combined value generated by the yielding function
     */
    public static <T1, T2, T3, R1, R2, R3, R> CompletableFuture<R> forEach4(CompletableFuture<? extends T1> value1,
                                                                            Function<? super T1, ? extends CompletableFuture<R1>> value2,
                                                                            BiFunction<? super T1, ? super R1, ? extends CompletableFuture<R2>> value3,
                                                                            Fn3<? super T1, ? super R1, ? super R2, ? extends CompletableFuture<R3>> value4,
                                                                            Fn4<? super T1, ? super R1, ? super R2, ? super R3, ? extends R> yieldingFunction) {

        return value1.thenCompose(in -> {

            CompletableFuture<R1> a = value2.apply(in);
            return a.thenCompose(ina -> {
                CompletableFuture<R2> b = value3.apply(in,ina);
                return b.thenCompose(inb -> {
                    CompletableFuture<R3> c = value4.apply(in,ina,inb);
                    return c.thenApply(in2 -> yieldingFunction.apply(in, ina, inb, in2));
                });

            });

        });

    }



    /**
     * Perform a For Comprehension over a CompletableFuture, accepting 2 generating function.
     * This results in a three level nested internal iteration over the provided CompletableFutures.
     *
     *  <pre>
     * {@code
     *
     *   import static com.aol.cyclops2.reactor.CompletableFutures.forEach3;
     *
    forEach3(CompletableFuture.just(1),
    a-> CompletableFuture.just(a+1),
    (a,b) -> CompletableFuture.<Integer>just(a+b),
    Tuple::tuple)
     *
     * }
     * </pre>
     *
     * @param value1 top level CompletableFuture
     * @param value2 Nested CompletableFuture
     * @param value3 Nested CompletableFuture
     * @param yieldingFunction Generates a result per combination
     * @return CompletableFuture with a combined value generated by the yielding function
     */
    public static <T1, T2, R1, R2, R> CompletableFuture<R> forEach3(CompletableFuture<? extends T1> value1,
                                                                    Function<? super T1, ? extends CompletableFuture<R1>> value2,
                                                                    BiFunction<? super T1, ? super R1, ? extends CompletableFuture<R2>> value3,
                                                                    Fn3<? super T1, ? super R1, ? super R2, ? extends R> yieldingFunction) {

        return value1.thenCompose(in -> {

            CompletableFuture<R1> a = value2.apply(in);
            return a.thenCompose(ina -> {
                CompletableFuture<R2> b = value3.apply(in,ina);


                    return b.thenApply(in2 -> yieldingFunction.apply(in, ina, in2));


            });

        });

    }


    /**
     * Perform a For Comprehension over a CompletableFuture, accepting a generating function.
     * This results in a two level nested internal iteration over the provided CompletableFutures.
     *
     *  <pre>
     * {@code
     *
     *   import static com.aol.cyclops2.reactor.CompletableFutures.forEach;
     *
    forEach(CompletableFuture.just(1),
    a-> CompletableFuture.just(a+1),
    Tuple::tuple)
     *
     * }
     * </pre>
     *
     * @param value1 top level CompletableFuture
     * @param value2 Nested CompletableFuture
     * @param yieldingFunction Generates a result per combination
     * @return CompletableFuture with a combined value generated by the yielding function
     */
    public static <T, R1, R> CompletableFuture<R> forEach2(CompletableFuture<? extends T> value1, Function<? super T, CompletableFuture<R1>> value2,
                                                          BiFunction<? super T, ? super R1, ? extends R> yieldingFunction) {

        return value1.thenCompose(in -> {

            CompletableFuture<R1> a = value2.apply(in);
            return a.thenApply(ina -> yieldingFunction.apply(in, ina));


            });


    }


    /**
     * Asynchronous sequence operation that convert a Collection of Futures to a Future with a List
     * 
     * <pre>
     * {@code 
     *   CompletableFuture<ListX<Integer>> futures =CompletableFuture.sequence(ListX.of(
     *                                                          CompletableFuture.completedFuture(10),
     *                                                          CompletableFuture.completedFuture(1)));
         //ListX.of(10,1)
     * 
     * }
     * </pre>
     * 
     * 
     * @param fts Collection of Futures to Sequence into a Future with a List
     * @return Future with a List
     */
    public static <T> CompletableFuture<ListX<T>> sequence(final CollectionX<CompletableFuture<T>> fts) {
        return sequence(fts.stream()).thenApply(s -> s.toListX());
    }
    /**
     * Asynchronous sequence operation that convert a Stream of FutureWs to a Future with a Stream
     * 
     * <pre>
     * {@code 
     *   CompletableFuture<ListX<Integer>> futures =CompletableFuture.sequence(ListX.of(
     *                                                          CompletableFuture.completedFuture(10),
     *                                                          CompletableFuture.completedFuture(1)));
         //ListX.of(10,1)
     * 
     * }
     * </pre>
     * 
     * 
     * @param fts Stream of Futures to Sequence into a Future with a Stream
     * @return Future with a Stream
     */
    public static <T> CompletableFuture<ReactiveSeq<T>> sequence(final Stream<CompletableFuture<T>> fts) {
        return AnyM.sequence(fts.map(AnyM::fromCompletableFuture), Witness.completableFuture.INSTANCE)
                .map(ReactiveSeq::fromStream)
                .to(Witness::completableFuture);
        
    }
    /**
     * 
     * Asynchronously accumulate the results only from those Futures which have completed successfully.
     * Also @see {@link CompletableFutures#accumulate(CollectionX, Reducer)} if you would like a failure to result in a CompletableFuture
     * with an error
     * <pre>
     * {@code 
     * 
     * CompletableFuture<Integer> just = CompletableFuture.completedFuture(10);
      CompletableFuture<Integer> none = Future.ofError(new NoSuchElementException())
                                               .getFuture();
       
     * CompletableFuture<PSetX<Integer>> futures = CompletableFutures.accumulateSuccess(ListX.of(just,none,CompletableFuture.completedFuture(1)),Reducers.toPSetX());
       
       //CompletableFuture[PSetX[10,1]]
     *  }
     *  </pre>
     * 
     * @param fts Collection of Futures to accumulate successes
     * @param reducer Reducer to accumulate results
     * @return CompletableFuture asynchronously populated with the accumulate success operation
     */
    public static <T, R> CompletableFuture<R> accumulateSuccess(final CollectionX<CompletableFuture<T>> fts, final Reducer<R> reducer) {
        CompletableFuture<R> result = new CompletableFuture<>();
        Stream<T> successes = fts.stream()
                                                    .filter(ft->!ft.isCompletedExceptionally())
                                                    .map(CompletableFuture::join);
        CompletableFuture.allOf(fts.toArray(new CompletableFuture[0]))
                        .thenRun(()-> result.complete(reducer.mapReduce(successes)))
                        .exceptionally(e->{ result.complete(reducer.mapReduce(successes)); return null;});
        
        return result;    
    }
    /**
     * Asynchronously accumulate the results only from those Futures which have completed successfully, using the supplied mapping function to
     * convert the data from each Future before reducing them using the supplied Monoid (a combining BiFunction/BinaryOperator and identity element that takes two
     * input values of the same type and returns the combined result) {@see cyclops2.Monoids }.
     * 
     * <pre>
     * {@code 
     * CompletableFuture<String> future = CompletableFutures.accumulate(ListX.of(CompletableFuture.completedFuture(10),CompletableFuture.completedFuture(1)),i->""+i,Monoids.stringConcat);
        //CompletableFuture["101"]
     * }
     * </pre>
     * 
     * @param fts Collection of Futures to accumulate successes
     * @param mapper Mapping function to be applied to the result of each Future
     * @param reducer Monoid to combine values from each Future
     * @return CompletableFuture asynchronously populated with the accumulate operation
     */
    public static <T, R> CompletableFuture<R> accumulateSuccess(final CollectionX<CompletableFuture<T>> fts,final Function<? super T, R> mapper,final Monoid<R> reducer) {
        CompletableFuture<R> result = new CompletableFuture<>();
        ReactiveSeq<R> successes = fts.stream()
                                      .filter(ft->!ft.isCompletedExceptionally())
                                      .map(CompletableFuture::join)
                                      .map(mapper);
        CompletableFuture.allOf(fts.toArray(new CompletableFuture[0]))
                        .thenRun(()-> result.complete(successes.reduce(reducer)))
                        .exceptionally(e->{ result.complete(successes.reduce(reducer)); return null;});
        
        return result;    
    }
    /**
     * Asynchronously accumulate the results only from those Futures which have completed successfully,
     *  reducing them using the supplied Monoid (a combining BiFunction/BinaryOperator and identity element that takes two
     * input values of the same type and returns the combined result) {@see cyclops2.Monoids }
     * 
     * <pre>
     * {@code 
     * CompletableFuture<Integer> just =CompletableFuture.completedFuture(10);
     * CompletableFuture<Integer> future =CompletableFutures.accumulate(Monoids.intSum, ListX.of(just,CompletableFuture.completedFuture(1)));
       //CompletableFuture[11]
     * }
     * </pre>
     * 
     * 
     * @param fts Collection of Futures to accumulate successes
     * @param reducer Monoid to combine values from each Future
     * @return CompletableFuture asynchronously populated with the accumulate operation
     */
    public static <T, R> CompletableFuture<T> accumulateSuccess(final Monoid<T> reducer,final CollectionX<CompletableFuture<T>> fts) {
        CompletableFuture<T> result = new CompletableFuture<>();
        ReactiveSeq<T> successes = fts.stream()
                                      .filter(ft->!ft.isCompletedExceptionally())
                                      .map(CompletableFuture::join);
        CompletableFuture.allOf(fts.toArray(new CompletableFuture[0]))
                        .thenRun(()-> result.complete(successes.reduce(reducer)))
                        .exceptionally(e->{ result.complete(successes.reduce(reducer)); return null;});
        
        return result;    
    }
    /**
     * Asynchronously accumulate the results of Futures, a single failure will cause a failed result, using the supplied Reducer {@see cyclops2.Reducers}
     * <pre>
     * {@code 
     * 
     * CompletableFuture<Integer> just =CompletableFuture.completedFuture(10);
       CompletableFuture<Integer> none = Future.ofError(new NoSuchElementException()).getFuture();
       
     * CompletableFuture<PSetX<Integer>> futures = CompletableFutures.accumulateSuccess(ListX.of(just,none,CompletableFuture.completedFuture(1)),Reducers.toPSetX());
       
       //CompletableFuture[PSetX[10,1]]
     *  }
     *  </pre>
     * 
     * @param fts Collection of Futures to accumulate successes
     * @param reducer Reducer to accumulate results
     * @return Future asynchronously populated with the accumulate success operation
     */
    public static <T, R> CompletableFuture<R> accumulate(final CollectionX<CompletableFuture<T>> fts, final Reducer<R> reducer) {
        return sequence(fts).thenApply(s -> s.mapReduce(reducer));
    }
    /**
     * Asynchronously accumulate the results of a batch of Futures which using the supplied mapping function to
     * convert the data from each Future before reducing them using the supplied supplied Monoid (a combining BiFunction/BinaryOperator and identity element that takes two
     * input values of the same type and returns the combined result) {@see cyclops2.Monoids }.
     * A single Failure results in a Failed  Future.
     * 
     * <pre>
     * {@code 
     * CompletableFuture<String> future = Future.accumulate(ListX.of(CompletableFuture.completedFuture(10),CompletableFuture.completedFuture(1)),i->""+i,Monoids.stringConcat);
        //CompletableFuture["101"]
     * }
     * </pre>
     * 
     * @param fts Collection of Futures to accumulate successes
     * @param mapper Mapping function to be applied to the result of each Future
     * @param reducer Monoid to combine values from each Future
     * @return CompletableFuture asynchronously populated with the accumulate operation
     */
    public static <T, R> CompletableFuture<R> accumulate(final CollectionX<CompletableFuture<T>> fts, final Function<? super T, R> mapper,
            final Monoid<R> reducer) {
        return sequence(fts).thenApply(s -> s.map(mapper)
                                             .reduce(reducer));
    }
    /**
     * Asynchronously accumulate the results only from the provided Futures,
     *  reducing them using the supplied Monoid (a combining BiFunction/BinaryOperator and identity element that takes two
     * input values of the same type and returns the combined result) {@see cyclops2.Monoids }.
     * 
     * A single Failure results in a Failed  Future.
     * 
     * <pre>
     * {@code 
     * CompletableFuture<Integer> just =CompletableFuture.completedFuture(10);
     * 
     * CompletableFuture<Integer> future =CompletableFutures.accumulate(Monoids.intSum,ListX.of(just,CompletableFuture.completableFuture(1)));
       //CompletableFuture[11]
     * }
     * </pre>
     * 
     * 
     * @param fts Collection of Futures to accumulate successes
     * @param reducer Monoid to combine values from each Future
     * @return CompletableFuture asynchronously populated with the accumulate operation
     */
    public static <T> CompletableFuture<T> accumulate(final Monoid<T> reducer, final CollectionX<CompletableFuture<T>> fts
           ) {
        return sequence(fts).thenApply(s -> s
                                             .reduce(reducer));
    }
    /**
     * Schedule the population of a CompletableFuture from the provided Supplier, the provided Cron (Quartz format) expression will be used to
     * trigger the population of the CompletableFuture. The provided ScheduledExecutorService provided the thread on which the 
     * Supplier will be executed.
     * 
     * <pre>
     * {@code 
     *  
     *    CompletableFuture<String> future = CompletableFutures.schedule("* * * * * ?", Executors.newScheduledThreadPool(1), ()->"hello");
     *    
     *    //CompletableFuture["hello"]
     * 
     * }</pre>
     * 
     * 
     * @param cron Cron expression in Quartz format
     * @param ex ScheduledExecutorService used to execute the provided Supplier
     * @param t The Supplier to execute to populate the CompletableFuture
     * @return CompletableFuture populated on a Cron based Schedule
     */
    public static <T> CompletableFuture<T> schedule(final String cron, final ScheduledExecutorService ex, final Supplier<T> t) {
        return Future.schedule(cron, ex, t)
                      .getFuture();
    }
    /**
     * Schedule the population of a CompletableFuture from the provided Supplier after the specified delay. The provided ScheduledExecutorService provided the thread on which the 
     * Supplier will be executed.
     * <pre>
     * {@code 
     *  
     *    CompletableFuture<String> future = CompletableFutures.schedule(10l, Executors.newScheduledThreadPool(1), ()->"hello");
     *    
     *    //CompletableFuture["hello"]
     * 
     * }</pre>
     * 
     * @param delay Delay after which the CompletableFuture should be populated
     * @param ex ScheduledExecutorService used to execute the provided Supplier
     * @param t he Supplier to execute to populate the CompletableFuture
     * @return CompletableFuture populated after the specified delay
     */
    public static <T> CompletableFuture<T> schedule(final long delay, final ScheduledExecutorService ex, final Supplier<T> t) {
        return Future.schedule(delay, ex, t)
                      .getFuture();
    }
    /**
     * Combine a CompletableFuture with the provided Value asynchronously (if not completed) using the supplied BiFunction
     * 
     * <pre>
     * {@code 
     *  CompletableFutures.combine(CompletableFuture.completedFuture(10),Maybe.just(20), this::add)
     *  //CompletableFuture [30]
     *  
     *  private int add(int a, int b) {
            return a + b;
        }
     *  
     * }
     * </pre>
     * 
     * @param f CompletableFuture  to combine with a value
     * @param v Value  to combine with
     * @param fn Combining function
     * @return CompletableFuture  combined with supplied value
     */
    public static <T1, T2, R> CompletableFuture<R> combine(final CompletableFuture<? extends T1> f, final Value<? extends T2> v,
            final BiFunction<? super T1, ? super T2, ? extends R> fn) {
        return narrow(Future.of(f)
                             .combine(v, fn)
                             .getFuture());
    }

    /**
     * Combine a CompletableFuture with the provided CompletableFuture asynchronously (if not completed) using the supplied BiFunction
     * 
     * <pre>
     * {@code 
     *  CompletableFutures.combine(CompletableFuture.completedFuture(10),CompletableFuture.completedFuture(20), this::add)
     *  //CompletableFuture [30]
     *  
     *  private int add(int a, int b) {
            return a + b;
        }
     *  
     * }
     * </pre>
     * 
     * @param f CompletableFuture  to combine with a value
     * @param v Value  to combine with
     * @param fn Combining function
     * @return CompletableFuture  combined with supplied value
     */
    public static <T1, T2, R> CompletableFuture<R> combine(final CompletableFuture<? extends T1> f, final CompletableFuture<? extends T2> v,
            final BiFunction<? super T1, ? super T2, ? extends R> fn) {
        return narrow(Future.of(f)
                             .combine(Future.of(v), fn)
                             .getFuture());
    }
    /**
     * Combine an CompletableFuture with the provided Iterable (selecting one element if present) using the supplied BiFunction
     * <pre>
     * {@code 
     *  CompletableFutures.zip(CompletableFuture.completedFuture(10),Arrays.asList(20), this::add)
     *  //CompletableFuture[30]
     *  
     *  private int add(int a, int b) {
            return a + b;
        }
     *  
     * }
     * </pre>
     * @param f CompletableFuture to combine with first element in Iterable (if present)
     * @param v Iterable to combine
     * @param fn Combining function
     * @return CompletableFuture combined with supplied Iterable
     */
    public static <T1, T2, R> CompletableFuture<R> zip(final CompletableFuture<? extends T1> f, final Iterable<? extends T2> v,
            final BiFunction<? super T1, ? super T2, ? extends R> fn) {
        return narrow(Future.of(f)
                             .zip(v, fn)
                             .getFuture());
    }
    /**
     * Combine an CompletableFuture with the provided Publisher (selecting one element if present) using the supplied BiFunction
     * <pre>
     * {@code 
     *  CompletableFutures.zip(Flux.just(10),CompletableFuture.completedResult(10), this::add)
     *  //CompletableFuture[30]
     *  
     *  private int add(int a, int b) {
            return a + b;
        }
     *  
     * }
     * </pre> 
     * 
     * @param p Publisher to combine
     * @param f  CompletableFuture to combine with
     * @param fn Combining function
     * @return CompletableFuture combined with supplied Publisher
     */
    public static <T1, T2, R> CompletableFuture<R> zip(final Publisher<? extends T2> p, final CompletableFuture<? extends T1> f,
            final BiFunction<? super T1, ? super T2, ? extends R> fn) {
        return narrow(Future.of(f)
                             .zipP(p,fn)
                             .getFuture());
    }
    /**
     * Narrow covariant type parameter
     * 
     * @param broad CompletableFuture with covariant type parameter
     * @return Narrowed Optional
     */
    public static <T> CompletableFuture<T> narrow(final CompletableFuture<? extends T> f) {
        return (CompletableFuture<T>) f;
    }
    /**
     * Companion class for creating Type Class instances for working with CompletableFutures
     * @author johnmcclean
     *
     */
    @UtilityClass
    public static class CompletableFutureInstances {


        /**
         *
         * Transform a future, mulitplying every element by 2
         *
         * <pre>
         * {@code
         *  CompletableFutureKind<Integer> future = CompletableFutures.functor().map(i->i*2, CompletableFutureKind.widen(CompletableFuture.completedFuture(1,2,3));
         *
         *  //[2,4,6]
         *
         *
         * }
         * </pre>
         *
         * An example fluent api working with CompletableFutures
         * <pre>
         * {@code
         *   CompletableFutureKind<Integer> future = CompletableFutures.unit()
        .unit("hello")
        .then(h->CompletableFutures.functor().map((String v) ->v.length(), h))
        .convert(CompletableFutureKind::narrowK);
         *
         * }
         * </pre>
         *
         *
         * @return A functor for CompletableFutures
         */
        public static <T,R>Functor<CompletableFutureKind.µ> functor(){
            BiFunction<CompletableFutureKind<T>,Function<? super T, ? extends R>,CompletableFutureKind<R>> map = CompletableFutureInstances::map;
            return General.functor(map);
        }
        /**
         * <pre>
         * {@code
         * CompletableFutureKind<String> future = CompletableFutures.unit()
        .unit("hello")
        .convert(CompletableFutureKind::narrowK);

        //CompletableFuture.completedFuture("hello"))
         *
         * }
         * </pre>
         *
         *
         * @return A factory for CompletableFutures
         */
        public static <T> Pure<CompletableFutureKind.µ> unit(){
            return General.<CompletableFutureKind.µ,T>unit(CompletableFutureInstances::of);
        }
        /**
         *
         * <pre>
         * {@code
         * import static com.aol.cyclops.hkt.jdk.CompletableFutureKind.widen;
         * import static com.aol.cyclops.util.function.Lambda.l1;
         *
        CompletableFutures.applicative()
        .ap(widen(asCompletableFuture(l1(this::multiplyByTwo))),widen(asCompletableFuture(3)));
         *
         * //[6]
         * }
         * </pre>
         *
         *
         * Example fluent API
         * <pre>
         * {@code
         * CompletableFutureKind<Function<Integer,Integer>> futureFn =CompletableFutures.unit()
         *                                                  .unit(Lambda.l1((Integer i) ->i*2))
         *                                                  .convert(CompletableFutureKind::narrowK);

        CompletableFutureKind<Integer> future = CompletableFutures.unit()
        .unit("hello")
        .then(h->CompletableFutures.functor().map((String v) ->v.length(), h))
        .then(h->CompletableFutures.applicative().ap(futureFn, h))
        .convert(CompletableFutureKind::narrowK);

        //CompletableFuture.completedFuture("hello".length()*2))
         *
         * }
         * </pre>
         *
         *
         * @return A zipper for CompletableFutures
         */
        public static <T,R> Applicative<CompletableFutureKind.µ> applicative(){
            BiFunction<CompletableFutureKind< Function<T, R>>,CompletableFutureKind<T>,CompletableFutureKind<R>> ap = CompletableFutureInstances::ap;
            return General.applicative(functor(), unit(), ap);
        }
        /**
         *
         * <pre>
         * {@code
         * import static com.aol.cyclops.hkt.jdk.CompletableFutureKind.widen;
         * CompletableFutureKind<Integer> future  = CompletableFutures.monad()
        .flatMap(i->widen(CompletableFutureX.range(0,i)), widen(CompletableFuture.completedFuture(3)))
        .convert(CompletableFutureKind::narrowK);
         * }
         * </pre>
         *
         * Example fluent API
         * <pre>
         * {@code
         *    CompletableFutureKind<Integer> future = CompletableFutures.unit()
        .unit("hello")
        .then(h->CompletableFutures.monad().flatMap((String v) ->CompletableFutures.unit().unit(v.length()), h))
        .convert(CompletableFutureKind::narrowK);

        //CompletableFuture.completedFuture("hello".length())
         *
         * }
         * </pre>
         *
         * @return Type class with monad functions for CompletableFutures
         */
        public static <T,R> Monad<CompletableFutureKind.µ> monad(){

            BiFunction<Higher<CompletableFutureKind.µ,T>,Function<? super T, ? extends Higher<CompletableFutureKind.µ,R>>,Higher<CompletableFutureKind.µ,R>> flatMap = CompletableFutureInstances::flatMap;
            return General.monad(applicative(), flatMap);
        }
        /**
         *
         * <pre>
         * {@code
         *  CompletableFutureKind<String> future = CompletableFutures.unit()
        .unit("hello")
        .then(h->CompletableFutures.monadZero().filter((String t)->t.startsWith("he"), h))
        .convert(CompletableFutureKind::narrowK);

        //CompletableFuture.completedFuture("hello"));
         *
         * }
         * </pre>
         *
         *
         * @return A filterable monad (with default value)
         */
        public static <T,R> MonadZero<CompletableFutureKind.µ> monadZero(){

            return General.monadZero(monad(), CompletableFutureKind.widen(new CompletableFuture<T>()));
        }
        /**
         * <pre>
         * {@code
         *  CompletableFutureKind<Integer> future = CompletableFutures.<Integer>monadPlus()
        .plus(CompletableFutureKind.widen(CompletableFuture.completedFuture()), CompletableFutureKind.widen(CompletableFuture.completedFuture(10)))
        .convert(CompletableFutureKind::narrowK);
        //CompletableFuture.completedFuture(10))
         *
         * }
         * </pre>
         * @return Type class for combining CompletableFutures by concatenation
         */
        public static <T> MonadPlus<CompletableFutureKind.µ> monadPlus(){
            Monoid<CompletableFuture<T>> mn = Monoids.firstCompleteCompletableFuture();
            Monoid<CompletableFutureKind<T>> m = Monoid.of(CompletableFutureKind.widen(mn.zero()), (f, g)-> CompletableFutureKind.widen(
                    mn.apply(CompletableFutureKind.narrow(f), CompletableFutureKind.narrow(g))));

            Monoid<Higher<CompletableFutureKind.µ,?>> m2= (Monoid)m;
            return General.monadPlus(monadZero(),m2);
        }
        /**
         *
         * <pre>
         * {@code
         *  Monoid<CompletableFutureKind<Integer>> m = Monoid.of(CompletableFutureKind.widen(CompletableFuture.completedFuture()), (a,b)->a.isEmpty() ? b : a);
        CompletableFutureKind<Integer> future = CompletableFutures.<Integer>monadPlus(m)
        .plus(CompletableFutureKind.widen(CompletableFuture.completedFuture(5)), CompletableFutureKind.widen(CompletableFuture.completedFuture(10)))
        .convert(CompletableFutureKind::narrowK);
        //CompletableFuture.completedFuture(5))
         *
         * }
         * </pre>
         *
         * @param m Monoid to use for combining CompletableFutures
         * @return Type class for combining CompletableFutures
         */
        public static  <T> MonadPlus<CompletableFutureKind.µ> monadPlus(Monoid<CompletableFutureKind<T>> m){
            Monoid<Higher<CompletableFutureKind.µ,?>> m2= (Monoid)m;
            return General.monadPlus(monadZero(),m2);
        }

        /**
         * @return Type class for traversables with traverse / sequence operations
         */
        public static <C2,T> Traverse<CompletableFutureKind.µ> traverse(){

            return General.traverseByTraverse(applicative(), CompletableFutureInstances::traverseA);
        }

        /**
         *
         * <pre>
         * {@code
         * int sum  = CompletableFutures.foldable()
        .foldLeft(0, (a,b)->a+b, CompletableFutureKind.widen(CompletableFuture.completedFuture(3)));

        //3
         *
         * }
         * </pre>
         *
         *
         * @return Type class for folding / reduction operations
         */
        public static <T> Foldable<CompletableFutureKind.µ> foldable(){
            BiFunction<Monoid<T>,Higher<CompletableFutureKind.µ,T>,T> foldRightFn =  (m, l)-> m.apply(m.zero(), CompletableFutureKind.narrow(l).join());
            BiFunction<Monoid<T>,Higher<CompletableFutureKind.µ,T>,T> foldLeftFn = (m, l)->  m.apply(m.zero(), CompletableFutureKind.narrow(l).join());
            return General.foldable(foldRightFn, foldLeftFn);
        }
        public static <T> Comonad<CompletableFutureKind.µ> comonad(){
            Function<? super Higher<CompletableFutureKind.µ, T>, ? extends T> extractFn = maybe -> maybe.convert(CompletableFutureKind::narrow).join();
            return General.comonad(functor(), unit(), extractFn);
        }

        private <T> CompletableFutureKind<T> of(T value){
            return CompletableFutureKind.widen(CompletableFuture.completedFuture(value));
        }
        private static <T,R> CompletableFutureKind<R> ap(CompletableFutureKind<Function< T, R>> lt, CompletableFutureKind<T> future){
            return CompletableFutureKind.widen(lt.thenCombine(future, (a, b)->a.apply(b)));

        }
        private static <T,R> Higher<CompletableFutureKind.µ,R> flatMap(Higher<CompletableFutureKind.µ,T> lt, Function<? super T, ? extends  Higher<CompletableFutureKind.µ,R>> fn){
            return CompletableFutureKind.widen(CompletableFutureKind.narrow(lt).thenCompose(fn.andThen(CompletableFutureKind::narrowK)));
        }
        private static <T,R> CompletableFutureKind<R> map(CompletableFutureKind<T> lt, Function<? super T, ? extends R> fn){
            return CompletableFutureKind.widen(lt.thenApply(fn));
        }


        private static <C2,T,R> Higher<C2, Higher<CompletableFutureKind.µ, R>> traverseA(Applicative<C2> applicative, Function<? super T, ? extends Higher<C2, R>> fn,
                                                                                         Higher<CompletableFutureKind.µ, T> ds){
            CompletableFuture<T> future = CompletableFutureKind.narrow(ds);
            return applicative.map(CompletableFutureKind::completedFuture, fn.apply(future.join()));
        }

    }

}
