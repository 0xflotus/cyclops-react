package cyclops.function;

import java.util.function.BiFunction;
import java.util.function.Function;

import com.aol.cyclops.types.Functor;

/**
 * An interface that represents the Reader monad
 * 
 * A technique for functional dependency injection. Functions rather than values
 * are manipulated and dependencies injected into Functions to execute them.
 * 
 * {@see <a href="https://medium.com/@johnmcclean/dependency-injection-using-the-reader-monad-in-java8-9056d9501c75">Dependency injection using the Reader Monad in Java 8</a>}
 * 
 * <pre>
 * {@code 
 * For comprehension with the Reader Monad, using curried syntax :-
 *  
 * import com.aol.cyclops.control.For;
 * 
 * Reader<UserRepository,Integer> res =  For.reader(depth1("bob"))
                                            .reader(a->depth2("bob"))
                                            .reader(a->b->depth3("bob"))
                                            .reader(a->b->c->depth3("bob"))
                                            .reader(a->b->c->d->depth4("bob"))
                                            .reader(a->b->c->d->e->depth5("bob"))
                                            .reader(a->b->c->d->e->f->depth5("bob"))
                                            .reader(a->b->c->d->e->f->g->depth6("bob"))
                                            .yield(a->b->c->d->e->f->g->h->a+b+c+d+e+f+g+h).unwrap();
   res.apply(new UserRepositoryImpl())
   //29
   private Reader<UserRepository,Integer> depth8(String name){
        return repo->depth7(name).apply(repo)+1;
   }
 * 
 * 
 * }
 * </pre>
 * 
 * 
 * @author johnmcclean
 *
 * @param <T> Current input type of Function
 * @param <R> Current return type of Function
 */
public interface Reader<T, R> extends Fn1<T, R>, Functor<R> {

    /* (non-Javadoc)
     * @see com.aol.cyclops.types.Functor#map(java.util.function.Function)
     */
    @Override
    default <R1> Reader<T, R1> map(final Function<? super R, ? extends R1> f2) {
        return FluentFunctions.of(this.andThen(f2));
    }

    /**
     * FlatMap this Reader by applying the prodived function and unnesting to a single Reader
     * 
     * @param f Transformation function to be flattened
     * @return Transformed Reader
     */
    default <R1> Reader<T, R1> flatMap(final Function<? super R, ? extends Reader<T, R1>> f) {
        return FluentFunctions.of(a -> f.apply(apply(a))
                                        .apply(a));
    }

   /*
    * Perform a For Comprehension over a Reader, accepting 3 generating function.
            * This results in a four level nested internal iteration over the provided Readers.
     *
             *  <pre>
     * {@code
     *
     *   import static com.aol.cyclops.reactor.Readers.forEach4;
     *
        forEach4(Reader.just(1),
                a-> Reader.just(a+1),
                (a,b) -> Reader.<Integer>just(a+b),
                a                  (a,b,c) -> Reader.<Integer>just(a+b+c),
                Tuple::tuple)
     *
     * }
     * </pre>
            *
            * @param value1 top level Reader
     * @param value2 Nested Reader
     * @param value3 Nested Reader
     * @param value4 Nested Reader
     * @param yieldingFunction Generates a result per combination
     * @return Reader with a combined value generated by the yielding function
     */
    default <R1, R2, R3, R4> Reader<T,R4> forEach4(Function<? super R, ? extends Reader<T,R1>> value2,
                                                                 BiFunction<? super R, ? super R1, ? extends Reader<T,R2>> value3,
                                                                 Fn3<? super R, ? super R1, ? super R2, ? extends Reader<T,R3>> value4,
                                                                 Fn4<? super R, ? super R1, ? super R2, ? super R3, ? extends R4> yieldingFunction) {


        return this.flatMap(in -> {

            Reader<T,R1> a = value2.apply(in);
            return a.flatMap(ina -> {
                Reader<T,R2> b = value3.apply(in,ina);
                return b.flatMap(inb -> {

                    Reader<T,R3> c = value4.apply(in,ina,inb);

                    return c.map(in2 -> {

                         return yieldingFunction.apply(in, ina, inb, in2);

                    });

                });


            });


        });

    }



    /**
     * Perform a For Comprehension over a Reader, accepting 2 generating function.
     * This results in a three level nested internal iteration over the provided Readers.
     *
     *  <pre>
     * {@code
     *
     *   import static com.aol.cyclops.reactor.Readers.forEach3;
     *
    forEach3(Reader.just(1),
    a-> Reader.just(a+1),
    (a,b) -> Reader.<Integer>just(a+b),
    Tuple::tuple)
     *
     * }
     * </pre>
     *
     * @param value1 top level Reader
     * @param value2 Nested Reader
     * @param value3 Nested Reader
     * @param yieldingFunction Generates a result per combination
     * @return Reader with a combined value generated by the yielding function
     */
    default <R1, R2, R4> Reader<T,R4> forEach3(Function<? super R, ? extends Reader<T,R1>> value2,
                                                         BiFunction<? super R, ? super R1, ? extends Reader<T,R2>> value3,
                                                         Fn3<? super R, ? super R1, ? super R2, ? extends R4> yieldingFunction) {

        return this.flatMap(in -> {

            Reader<T,R1> a = value2.apply(in);
            return a.flatMap(ina -> {
                Reader<T,R2> b = value3.apply(in,ina);
                return b.map(in2 -> {
                        return yieldingFunction.apply(in, ina, in2);

                    });



            });

        });

    }


    /**
     * Perform a For Comprehension over a Reader, accepting a generating function.
     * This results in a two level nested internal iteration over the provided Readers.
     *
     *  <pre>
     * {@code
     *
     *   import static com.aol.cyclops.reactor.Readers.forEach;
     *
    forEach(Reader.just(1),
    a-> Reader.just(a+1),
    Tuple::tuple)
     *
     * }
     * </pre>
     *
     * @param value1 top level Reader
     * @param value2 Nested Reader
     * @param yieldingFunction Generates a result per combination
     * @return Reader with a combined value generated by the yielding function
     */
    default <R1, R4> Reader<T,R4> forEach2(Function<? super R, Reader<T,R1>> value2,
                                                BiFunction<? super R, ? super R1, ? extends R4> yieldingFunction) {

        return this.flatMap(in -> {

            Reader<T,R1> a = value2.apply(in);
            return a.map(in2 -> {
                    return yieldingFunction.apply(in, in2);

                });




        });


    }
}
